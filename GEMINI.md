# Gemini開発ノウハウ

このドキュメントは、Geminiとの対話を通じて実装およびデバッグを行う過程で得られた技術的な知見やノウハウを記録します。

## 開発環境とワークフロー

本プロジェクトでは、Pythonのパッケージ管理と仮想環境ツールとして`uv`を使用しています。また、定型タスクは`Taskfile.yml`に定義されています。

### ライブラリ管理
- **ライブラリの追加**:
  ```bash
  uv add <ライブラリ名>
  ```

### スクリプトの実行
- **メインスクリプトの実行**:
  ```bash
  uv run src/main.py
  ```

### 定型タスクの実行
`Taskfile.yml`で定義されたタスクは `uv run task <タスク名>` で実行できます。

**注意**: `uv run task` コマンドを使用する前に、`Taskfile.yml` が利用する開発依存関係（`go-task-bin`など）がインストールされている必要があります。以下のコマンドで開発依存関係をインストールしてください。
```bash
uv sync --extra dev
```

- **ユニットテストの実行**:
  ```bash
  uv run task test
  ```
- **コードのフォーマット**:
  ```bash
  uv run task format
  ```
- **Lint（静的解析）の修正**:
  ```bash
  uv run task lint-fix
  ```
- **フォーマットとLintのチェック**:
  ```bash
  uv run task check
  ```
  ※ このコマンドは修正に時間がかかる場合があるため、Geminiに指示されたタイミングで実施してください。

## Pythonスクリプトの実行とモジュール解決

### 問題
プロジェクトのルートディレクトリ外（例: `utils/`）にあるスクリプトから、`src/`ディレクトリ内のモジュールをインポートしようとすると`ModuleNotFoundError`が発生する。

- `utils/script.py` 内の `from src.components.my_module import ...` が失敗する。
- `src`内のモジュール間での相対インポート（例: `from journal_core import ...`）も、実行コンテキストによっては失敗する。

### 解決策
コード自体を修正するのではなく、スクリプトの**実行環境**を調整することで、インポートパスの競合を解決します。`PYTHONPATH`環境変数に、プロジェクトルート (`.`) と `src` ディレクトリの両方をコロン(`:`)で区切って設定します。

```bash
PYTHONPATH=.:src uv run path/to/your/script.py
```

- **`PYTHONPATH=.`**: `from src. ...` という形式のインポートを解決できるようにします。
- **`PYTHONPATH=src`**: `src`ディレクトリ内のモジュールが `from journal_core ...` のように、`src`をルートとして相互にインポートできるようにします。

この方法により、異なる実行コンテキストでも動作する、より堅牢な実行が可能になります。


## Gitコミットのベストプラクティス

本プロジェクトでは `pre-commit` フレームワークを導入しており、`git commit` 時に自動でコードの品質チェック（フォーマット、Lint、テスト）が実行されます。

### 初回セットアップ

リポジトリをクローンした後、以下のコマンドで開発依存関係とGitフックをセットアップしてください。この作業は一度だけで結構です。

```bash
# 開発依存関係（pre-commitなど）をインストール
uv sync --extra dev

# Gitフックをインストール
uv run pre-commit install
```

### コミット手順

1.  **変更内容の確認**: `git status`で変更・追加されたファイルの一覧を確認し、`git diff HEAD`で具体的な変更内容を精査します。
2.  **ステージング**: `git add <file1> <file2> ...` でコミット対象のファイルを選択します。
3.  **コミットの実行**: `git commit` を実行します。
    - この時、`pre-commit`フックが自動的に起動し、品質チェックが走ります。
    - チェックに失敗した場合、コミットは自動的に中断されます。エラーメッセージに従って問題を修正し、再度 `git add` してからコミットしてください。
4.  **ログスタイルの確認**: `git log -n 5`などで過去のコミットメッセージを閲覧し、件名や本文の書き方、言語、粒度などのスタイルを把握・踏襲します。
5.  **コミットメッセージの作成**:
    - **件名(Subject)**: 変更内容の要約を英語の命令形で記述します。（例: `feat: Add image processing feature`）
    - **本文(Body)**:
        - **Why**: なぜこの変更が必要だったのか（目的、背景、修正したバグなど）。
        - **What**: 何を変更したのか（新機能の概要、主要な修正点など）。
        - これらを明確に記述します。
6.  **コミットの完了**: 作成したメッセージでコミットを完了させます。

## 開発理念と行動原則

過去の失敗から学び、将来の愚行を繰り返さないための理念と原則。

1.  **目的の探求と確認 (Seek and Confirm True Intent)**
    - ユーザーの言葉の表面だけを捉えるのではなく、その背後にある**真の目的や根本的な課題**を常に探求する。
    - 特に、機能の不具合（バグ）への不満と、UIや仕様そのものへの不満は、全く別の問題として明確に区別し、解決策を提案する前にどちらの問題に取り組んでいるかを確認する。

2.  **指示範囲の厳守 (Strictly Adhere to Scope)**
    - ユーザーから指示された修正範囲を逸脱しない。特に、安易な「元に戻す」操作は、ユーザーが意図した改善まで破壊するリスクがあるため、絶対に行わない。
    - 修正範囲の拡大や、以前の状態への復帰が必要だと判断した場合は、必ずその理由と影響を説明し、ユーザーの承認を得る。

3.  **根拠に基づく開発 (Develop Based on Solid Evidence)**
    - **公式ドキュメント、ソースコード、現行の動作実績**を最優先の「根拠」とする。
    - ウェブ検索で得た非公式な情報や断片的なコードを鵜呑みにせず、その情報の信頼性を常に評価・検証する。不確実な情報に基づいて、システムの安定性に影響を与えるような重大な変更を行わない。

4.  **推測の排除と計画的アプローチ (Eliminate Guesswork, Approach Systematically)**
    - 根本原因が不明な複雑な問題に対し、安易な推測や場当たり的な試行錯誤で対処しない。
    - そのような状況では、まず問題を切り分けるための体系的なデバッグ計画を提示するか、`codebase_investigator`のような高度な分析ツールを早期に活用し、確固たる根拠を得てから修正に着手する。

5.  **既存コードの理解と計画的変更 (Understand Existing Code and Plan Changes)**
    - 既存コードを変更する際は、まずその意図を完全に理解する。その上で、**破壊的変更（Breaking Change）が必要な場合は、その必要性と影響範囲を明確にした上で、計画的に実行する。**
    - 「とりあえずやってみる」式の、無計画なコードの破壊や置き換えは、予期せぬ機能低下の最大の原因であるため、決して行わない。
