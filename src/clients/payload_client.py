import json
from dataclasses import asdict, dataclass, field
from datetime import datetime
from typing import Any
from urllib.parse import urljoin

import requests

from journal_core.interfaces import AbstractJournalClient
from journal_core.models import JournalEntry

from .payload_client_config import JOURNAL_COLLECTION_SLUG

# --- Payload CMS Specific Data Models ---
# These models map directly to the Payload CMS collection structure for sending data.
# The 'id' field is omitted as it's generated by Payload upon creation.


@dataclass
class PayloadCmsAttachment:
    file: str  # ID of the uploaded file in the 'files' collection


@dataclass
class PayloadCmsTag:
    tag: str


@dataclass
class PayloadCmsActivity:
    activity: str


@dataclass
class PayloadCmsLocation:
    latitude: float | None = None
    longitude: float | None = None
    name: str | None = None
    address: str | None = None
    altitude: float | None = None


@dataclass
class PayloadCmsWeather:
    temperature: float | None = None
    humidity: float | None = None
    pressure: float | None = None
    condition: str | None = None


@dataclass
class PayloadCmsSource:
    appName: str | None = None
    originalId: str | None = None
    importedAt: datetime | None = None
    rawData: Any | None = None


@dataclass
class PayloadCmsJournalEntry:
    entryAt: datetime
    # The main 'id' is handled by Payload. We use 'source.originalId' as our unique key.
    title: str | None = None
    richTextContent: Any | None = None
    textContent: str | None = None
    attachments: list[PayloadCmsAttachment] = field(default_factory=list)
    isFavorite: bool = False
    isPinned: bool = False
    notebook: str | None = None
    tags: list[PayloadCmsTag] = field(default_factory=list)
    moodLabel: str | None = None
    moodScore: float | None = None
    activities: list[PayloadCmsActivity] = field(default_factory=list)
    location: PayloadCmsLocation | None = None
    weather: PayloadCmsWeather | None = None
    timezone: str | None = None
    deviceName: str | None = None
    stepCount: int | None = None
    source: PayloadCmsSource | None = None
    created_at: datetime | None = None
    modified_at: datetime | None = None


# --- Conversion Functions ---


def _journal_entry_to_payload_cms_entry(entry: JournalEntry) -> PayloadCmsJournalEntry:
    """Converts a generic JournalEntry to a PayloadCmsJournalEntry."""

    # Handle nested structures
    location = PayloadCmsLocation(
        latitude=entry.location_lat,
        longitude=entry.location_lon,
        name=entry.location_name,
        address=entry.location_address,
        altitude=entry.location_altitude,
    )
    location_data = {k: v for k, v in asdict(location).items() if v is not None}

    weather = PayloadCmsWeather(
        temperature=entry.weather_temperature,
        condition=entry.weather_condition,
        humidity=entry.weather_humidity,
        pressure=entry.weather_pressure,
    )
    weather_data = {k: v for k, v in asdict(weather).items() if v is not None}

    # Use the entry's own ID as the source's originalId for tracking
    source = PayloadCmsSource(
        appName=entry.source_app_name,
        originalId=entry.id,  # Explicitly use entry.id here
        importedAt=entry.source_imported_at,
        rawData=json.loads(entry.source_raw_data) if isinstance(entry.source_raw_data, str) else entry.source_raw_data,
    )
    source_data = {k: v for k, v in asdict(source).items() if v is not None}

    # TODO: Implement attachment mapping
    attachments: list[PayloadCmsAttachment] = []

    # Handle rich text conversion
    rich_text_payload = None
    # If rich_text_content exists (e.g., from a Markdown source)
    if entry.rich_text_content:
        # This is a naive conversion. A proper one would parse Markdown to Slate.
        rich_text_payload = [{"type": "p", "children": [{"text": entry.rich_text_content}]}]
    # If text_content exists (likely HTML from Journey)
    elif entry.text_content:
        # We put the raw HTML in the plain text field. A proper conversion to Slate
        # would require a dedicated HTML-to-Slate library.
        pass

    return PayloadCmsJournalEntry(
        entryAt=entry.entry_at,
        title=entry.title,
        richTextContent=rich_text_payload,
        textContent=entry.text_content,
        attachments=attachments,
        isFavorite=entry.is_favorite,
        isPinned=entry.is_pinned,
        notebook=entry.notebook,
        tags=[PayloadCmsTag(tag=t) for t in entry.tags],
        moodLabel=entry.mood_label,
        moodScore=entry.mood_score,
        activities=[PayloadCmsActivity(activity=a) for a in entry.activities],
        location=PayloadCmsLocation(**location_data) if location_data else None,
        weather=PayloadCmsWeather(**weather_data) if weather_data else None,
        timezone=entry.timezone,
        deviceName=entry.device_name,
        stepCount=entry.step_count,
        source=PayloadCmsSource(**source_data) if source_data else None,
        created_at=entry.created_at,
        modified_at=entry.modified_at,
    )


def _payload_doc_to_journal_entry(doc: dict[str, Any]) -> JournalEntry:
    """Converts a Payload CMS document dictionary back to a JournalEntry object."""

    def parse_dt(dt_str: str | None) -> datetime | None:
        if not dt_str:
            return None
        try:
            return datetime.fromisoformat(dt_str.replace("Z", "+00:00"))
        except (ValueError, TypeError):
            return None

    source = doc.get("source", {})
    location = doc.get("location", {})
    weather = doc.get("weather", {})

    # A simple conversion from Slate JSON back to plain text for text_content
    text_content = doc.get("textContent")
    if not text_content and doc.get("richTextContent"):
        try:
            # Extract text from Slate's structure
            slate_nodes = doc["richTextContent"]
            text_parts = []
            for node in slate_nodes:
                for child in node.get("children", []):
                    if "text" in child:
                        text_parts.append(child["text"])
            text_content = "\n".join(text_parts)
        except (TypeError, KeyError):
            text_content = str(doc.get("richTextContent"))

    entry_at_dt = parse_dt(doc.get("entryAt"))
    if entry_at_dt is None:
        raise ValueError("JournalEntry requires 'entry_at' to be a valid datetime.")

    source_imported_at_dt = parse_dt(source.get("importedAt"))

    return JournalEntry(
        id=source.get("originalId", ""),
        entry_at=entry_at_dt,
        timezone=doc.get("timezone"),
        created_at=parse_dt(doc.get("created_at")),
        modified_at=parse_dt(doc.get("modified_at")),
        text_content=text_content,
        rich_text_content=json.dumps(doc.get("richTextContent")) if doc.get("richTextContent") else None,
        title=doc.get("title"),
        tags=[item.get("tag") for item in doc.get("tags", []) if item.get("tag")],
        notebook=doc.get("notebook"),
        is_favorite=doc.get("isFavorite", False),
        is_pinned=doc.get("isPinned", False),
        mood_label=doc.get("moodLabel"),
        mood_score=doc.get("moodScore"),
        activities=[item.get("activity") for item in doc.get("activities", []) if item.get("activity")],
        location_lat=location.get("latitude"),
        location_lon=location.get("longitude"),
        location_name=location.get("name"),
        location_address=location.get("address"),
        location_altitude=location.get("altitude"),
        weather_temperature=weather.get("temperature"),
        weather_condition=weather.get("condition"),
        weather_humidity=weather.get("humidity"),
        weather_pressure=weather.get("pressure"),
        device_name=doc.get("deviceName"),
        step_count=doc.get("stepCount"),
        media_attachments=[],  # TODO: Implement attachment download
        source_app_name=source.get("appName"),
        source_original_id=source.get("originalId"),
        source_imported_at=source_imported_at_dt if source_imported_at_dt else datetime.now(),
        source_raw_data=source.get("rawData"),
    )


class PayloadCmsJournalClient(AbstractJournalClient):
    """A client for interacting with a Payload CMS 'journals' collection."""

    def __init__(self, api_url: str, api_key: str, auth_collection_slug: str = "users"):
        if not api_url or not api_key:
            raise ValueError("Payload CMS API URL and API Key must be provided.")

        self.base_url = urljoin(api_url, "api/")
        self.headers = {
            "Authorization": f"{auth_collection_slug} API-Key {api_key}",
            "Content-Type": "application/json",
        }
        self.collection_slug = JOURNAL_COLLECTION_SLUG

    def _make_request(self, method: str, path: str, **kwargs) -> dict[str, Any]:
        """Helper function to make requests to the Payload API."""
        url = urljoin(self.base_url, path.lstrip("/"))
        try:
            response = requests.request(method, url, headers=self.headers, **kwargs)
            response.raise_for_status()
            # Handle cases where response body is empty (e.g., 204 No Content)
            if response.status_code == 204:
                return {}
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error making request to Payload CMS: {e}")
            if e.response:
                print(f"Response body: {e.response.text}")
            raise

    def _payload_entry_to_dict(self, entry: PayloadCmsJournalEntry) -> dict[str, Any]:
        """Converts a PayloadCmsJournalEntry to a dictionary, handling datetimes."""
        data = asdict(entry)

        def convert_datetimes(obj):
            if isinstance(obj, dict):
                return {k: convert_datetimes(v) for k, v in obj.items()}
            if isinstance(obj, list):
                return [convert_datetimes(i) for i in obj]
            if isinstance(obj, datetime):
                return obj.isoformat()
            return obj

        data = convert_datetimes(data)
        return {k: v for k, v in data.items() if v is not None}

    def register_entry(self, entry: JournalEntry) -> Any:
        payload_entry = _journal_entry_to_payload_cms_entry(entry)
        payload_dict = self._payload_entry_to_dict(payload_entry)
        return self._make_request("POST", self.collection_slug, json=payload_dict)

    def register_entries(self, entries: list[JournalEntry]) -> list[Any]:
        # Payload does not support batch creation out of the box, so we iterate.
        return [self.register_entry(entry) for entry in entries]

    def update_entry(self, entry: JournalEntry) -> Any:
        payload_entry = _journal_entry_to_payload_cms_entry(entry)
        payload_dict = self._payload_entry_to_dict(payload_entry)

        # Query by our unique key: source.originalId
        query_path = f"{self.collection_slug}?where[source.originalId][equals]={entry.id}"
        existing_docs = self._make_request("GET", query_path)

        if existing_docs.get("totalDocs", 0) > 0:
            doc_id = existing_docs["docs"][0]["id"]
            update_path = f"{self.collection_slug}/{doc_id}"
            return self._make_request("PATCH", update_path, json=payload_dict)
        else:
            print(f"Warning: Entry with source.originalId '{entry.id}' not found. Creating it.")
            return self.register_entry(entry)

    def update_entries(self, entries: list[JournalEntry]) -> list[Any]:
        return [self.update_entry(entry) for entry in entries]

    def get_existing_entry_ids(self) -> list[str]:
        response = self._make_request("GET", f"{self.collection_slug}?limit=1000&depth=0")
        return [
            doc.get("source", {}).get("originalId")
            for doc in response.get("docs", [])
            if doc.get("source", {}).get("originalId")
        ]

    def get_existing_entries_with_modified_at(self) -> dict[str, datetime]:
        response = self._make_request("GET", f"{self.collection_slug}?limit=1000&depth=1")

        entries_map = {}
        for doc in response.get("docs", []):
            original_id = doc.get("source", {}).get("originalId")
            modified_str = doc.get("updatedAt")
            if original_id and modified_str:
                try:
                    entries_map[original_id] = datetime.fromisoformat(modified_str.replace("Z", "+00:00"))
                except (ValueError, TypeError):
                    print(f"Warning: Could not parse 'updatedAt' for entry {original_id}: {modified_str}")
        return entries_map

    def download_journal_entries(self) -> list[JournalEntry]:
        """Downloads all journal entries from Payload and converts them to JournalEntry objects."""
        print("Downloading and parsing journal entries from Payload CMS...")
        response = self._make_request("GET", f"{self.collection_slug}?limit=1000&depth=1")

        entries = []
        for doc in response.get("docs", []):
            try:
                entries.append(_payload_doc_to_journal_entry(doc))
            except Exception as e:
                doc_id = doc.get("id", "N/A")
                print(f"Warning: Failed to parse document {doc_id} from Payload. Error: {e}")
        return entries
