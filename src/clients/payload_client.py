import json
import os
from dataclasses import asdict, dataclass, field
from datetime import datetime
from typing import Any
from urllib.parse import urljoin

import requests

from journal_core.interfaces import AbstractJournalClient
from journal_core.models import JournalEntry, MediaAttachment

from .payload_client_config import FILES_COLLECTION_SLUG, JOURNAL_COLLECTION_SLUG

# --- Payload CMS Specific Data Models ---
# These models map directly to the Payload CMS collection structure for sending data.
# The 'id' field is omitted as it's generated by Payload upon creation.


@dataclass
class PayloadCmsAttachment:
    """Represents an attachment link within a journal entry."""

    id: str  # The ID of the document in the 'attachments' collection of the journal entry
    file: str | dict[str, Any] | None = None  # ID of the file or the full file object
    processing_meta: dict | None = None


@dataclass
class PayloadCmsTag:
    tag: str


@dataclass
class PayloadCmsActivity:
    activity: str


@dataclass
class PayloadCmsLocation:
    latitude: float | None = None
    longitude: float | None = None
    name: str | None = None
    address: str | None = None
    altitude: float | None = None


@dataclass
class PayloadCmsWeather:
    temperature: float | None = None
    humidity: float | None = None
    pressure: float | None = None
    condition: str | None = None


@dataclass
class PayloadCmsSource:
    appName: str | None = None
    originalId: str | None = None
    importedAt: datetime | None = None
    rawData: Any | None = None


@dataclass
class PayloadCmsJournalEntry:
    entryAt: datetime
    # The main 'id' is handled by Payload. We use 'source.originalId' as our unique key.
    title: str | None = None
    richTextContent: Any | None = None
    textContent: str | None = None
    attachments: list[dict] | list[PayloadCmsAttachment] = field(default_factory=list)
    isFavorite: bool = False
    isPinned: bool = False
    notebook: str | None = None
    tags: list[PayloadCmsTag] = field(default_factory=list)
    moodLabel: str | None = None
    moodScore: float | None = None
    activities: list[PayloadCmsActivity] = field(default_factory=list)
    location: PayloadCmsLocation | None = None
    weather: PayloadCmsWeather | None = None
    timezone: str | None = None
    deviceName: str | None = None
    stepCount: int | None = None
    source: PayloadCmsSource | None = None
    created_at: datetime | None = None
    modified_at: datetime | None = None


# --- Conversion Functions ---


def _journal_entry_to_payload_cms_entry(entry: JournalEntry) -> PayloadCmsJournalEntry:
    """
    Converts a generic JournalEntry to a PayloadCmsJournalEntry for CREATION.
    NOTE: This function intentionally leaves `attachments` empty. The calling
    function (`register_entry`) is responsible for handling file uploads and
    populating the attachments array itself.
    """

    # Handle nested structures
    location = PayloadCmsLocation(
        latitude=entry.location_lat,
        longitude=entry.location_lon,
        name=entry.location_name,
        address=entry.location_address,
        altitude=entry.location_altitude,
    )
    location_data = {k: v for k, v in asdict(location).items() if v is not None}

    weather = PayloadCmsWeather(
        temperature=entry.weather_temperature,
        condition=entry.weather_condition,
        humidity=entry.weather_humidity,
        pressure=entry.weather_pressure,
    )
    weather_data = {k: v for k, v in asdict(weather).items() if v is not None}

    # Use the entry's own ID as the source's originalId for tracking
    source = PayloadCmsSource(
        appName=entry.source_app_name,
        originalId=entry.id,  # Explicitly use entry.id here
        importedAt=entry.source_imported_at,
        rawData=json.loads(entry.source_raw_data) if isinstance(entry.source_raw_data, str) else entry.source_raw_data,
    )
    source_data = {k: v for k, v in asdict(source).items() if v is not None}

    # ATTACHMENTS ARE HANDLED BY THE CALLING `register_entry` METHOD
    attachments: list[PayloadCmsAttachment] = []

    # Handle rich text conversion
    rich_text_payload = None
    # If rich_text_content exists (e.g., from a Markdown source)
    if entry.rich_text_content:
        # This is a naive conversion. A proper one would parse Markdown to Slate.
        rich_text_payload = [{"type": "p", "children": [{"text": entry.rich_text_content}]}]
    # If text_content exists (likely HTML from Journey)
    elif entry.text_content:
        # We put the raw HTML in the plain text field. A proper conversion to Slate
        # would require a dedicated HTML-to-Slate library.
        pass

    return PayloadCmsJournalEntry(
        entryAt=entry.entry_at,
        title=entry.title,
        richTextContent=rich_text_payload,
        textContent=entry.text_content,
        attachments=attachments,
        isFavorite=entry.is_favorite,
        isPinned=entry.is_pinned,
        notebook=entry.notebook,
        tags=[PayloadCmsTag(tag=t) for t in entry.tags],
        moodLabel=entry.mood_label,
        moodScore=entry.mood_score,
        activities=[PayloadCmsActivity(activity=a) for a in entry.activities],
        location=PayloadCmsLocation(**location_data) if location_data else None,
        weather=PayloadCmsWeather(**weather_data) if weather_data else None,
        timezone=entry.timezone,
        deviceName=entry.device_name,
        stepCount=entry.step_count,
        source=PayloadCmsSource(**source_data) if source_data else None,
        created_at=entry.created_at,
        modified_at=entry.modified_at,
    )


def _payload_doc_to_journal_entry(doc: dict[str, Any]) -> JournalEntry:
    """Converts a Payload CMS document dictionary back to a JournalEntry object."""

    def parse_dt(dt_str: str | None) -> datetime | None:
        if not dt_str:
            return None
        try:
            return datetime.fromisoformat(dt_str.replace("Z", "+00:00"))
        except (ValueError, TypeError):
            return None

    source = doc.get("source", {})
    location = doc.get("location", {})
    weather = doc.get("weather", {})

    # A simple conversion from Slate JSON back to plain text for text_content
    text_content = doc.get("textContent")
    if not text_content and doc.get("richTextContent"):
        try:
            # Extract text from Slate's structure
            slate_nodes = doc["richTextContent"]
            text_parts = []
            for node in slate_nodes:
                for child in node.get("children", []):
                    if "text" in child:
                        text_parts.append(child["text"])
            text_content = "\n".join(text_parts)
        except (TypeError, KeyError):
            text_content = str(doc.get("richTextContent"))

    entry_at_dt = parse_dt(doc.get("entryAt"))
    if entry_at_dt is None:
        raise ValueError("JournalEntry requires 'entry_at' to be a valid datetime.")

    source_imported_at_dt = parse_dt(source.get("importedAt"))

    # Parse attachments (thanks to depth=1)
    media_attachments: list[MediaAttachment] = []
    if doc.get("attachments"):
        for att_block in doc["attachments"]:
            file_obj = att_block.get("file")
            if file_obj and isinstance(file_obj, dict):
                media_attachments.append(
                    MediaAttachment(
                        id=att_block["id"],  # This is the ID of the attachment *block*
                        file_id=file_obj["id"],  # This is the ID of the file itself
                        filename=file_obj.get("filename"),
                        url=file_obj.get("url"),
                        mime_type=file_obj.get("mimeType"),
                        filesize=file_obj.get("filesize"),
                        processing_meta=att_block.get("processing_meta"),
                    )
                )

    return JournalEntry(
        id=source.get("originalId", ""),
        doc_id=doc.get("id"),
        entry_at=entry_at_dt,
        timezone=doc.get("timezone"),
        created_at=parse_dt(doc.get("created_at")),
        modified_at=parse_dt(doc.get("modified_at")),
        text_content=text_content,
        rich_text_content=json.dumps(doc.get("richTextContent")) if doc.get("richTextContent") else None,
        title=doc.get("title"),
        tags=[item.get("tag") for item in doc.get("tags", []) if item.get("tag")],
        notebook=doc.get("notebook"),
        is_favorite=doc.get("isFavorite", False),
        is_pinned=doc.get("isPinned", False),
        mood_label=doc.get("moodLabel"),
        mood_score=doc.get("moodScore"),
        activities=[item.get("activity") for item in doc.get("activities", []) if item.get("activity")],
        location_lat=location.get("latitude"),
        location_lon=location.get("longitude"),
        location_name=location.get("name"),
        location_address=location.get("address"),
        location_altitude=location.get("altitude"),
        weather_temperature=weather.get("temperature"),
        weather_condition=weather.get("condition"),
        weather_humidity=weather.get("humidity"),
        weather_pressure=weather.get("pressure"),
        device_name=doc.get("deviceName"),
        step_count=doc.get("stepCount"),
        media_attachments=media_attachments,
        source_app_name=source.get("appName"),
        source_original_id=source.get("originalId"),
        source_imported_at=source_imported_at_dt if source_imported_at_dt else datetime.now(),
        source_raw_data=source.get("rawData"),
    )


class PayloadCmsJournalClient(AbstractJournalClient):
    """A client for interacting with a Payload CMS 'journals' collection."""

    def __init__(self, api_url: str, api_key: str, auth_collection_slug: str = "users"):
        if not api_url or not api_key:
            raise ValueError("Payload CMS API URL and API Key must be provided.")

        self.api_url = api_url
        self.base_url = urljoin(self.api_url, "api/")
        self.headers = {
            "Authorization": f"{auth_collection_slug} API-Key {api_key}",
        }
        self.collection_slug = JOURNAL_COLLECTION_SLUG
        self.files_slug = FILES_COLLECTION_SLUG

    def _make_request(self, method: str, path: str, **kwargs) -> dict[str, Any]:
        """Helper function to make requests to the Payload API."""
        url = urljoin(self.base_url, path.lstrip("/"))
        # Ensure Content-Type is set if not provided for JSON-sending requests
        headers = self.headers.copy()
        if "json" in kwargs and "Content-Type" not in headers:
            headers["Content-Type"] = "application/json"

        try:
            response = requests.request(method, url, headers=headers, **kwargs)
            response.raise_for_status()
            # Handle cases where response body is empty (e.g., 204 No Content)
            if response.status_code == 204:
                return {}
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error making request to Payload CMS: {e}")
            if e.response:
                print(f"Response body: {e.response.text}")
            raise

    def get_file_details(self, file_id: str) -> dict[str, Any]:
        """Fetches the full document for a specific file."""
        return self._make_request("GET", f"{self.files_slug}/{file_id}")

    def download_file_by_url(self, url: str) -> bytes:
        """Downloads the binary content of a file from its full URL."""
        full_url = urljoin(self.api_url, url)
        try:
            response = requests.get(full_url, headers=self.headers)
            response.raise_for_status()
            return response.content
        except requests.exceptions.RequestException as e:
            print(f"Error downloading file from {full_url}: {e}")
            raise

    def upload_file(self, file_data: bytes, filename: str) -> dict[str, Any]:
        """Uploads a file to the 'files' collection."""
        files = {"file": (filename, file_data)}
        # No 'Content-Type' in headers for multipart/form-data, requests handles it
        upload_headers = self.headers.copy()
        if "Content-Type" in upload_headers:
            del upload_headers["Content-Type"]

        url = urljoin(self.base_url, self.files_slug.lstrip("/"))
        try:
            response = requests.post(url, headers=upload_headers, files=files)
            response.raise_for_status()
            return response.json()["doc"]  # The created doc is nested here
        except requests.exceptions.RequestException as e:
            print(f"Error uploading file to Payload CMS: {e}")
            if e.response:
                print(f"Response body: {e.response.text}")
            raise

    def update_journal_entry_attachments(self, journal_id: str, attachments_payload: list[dict]) -> Any:
        """Updates only the attachments field for a specific journal entry."""
        update_path = f"{self.collection_slug}/{journal_id}"
        payload = {"attachments": attachments_payload}
        return self._make_request("PATCH", update_path, json=payload)

    def _payload_entry_to_dict(self, entry: PayloadCmsJournalEntry) -> dict[str, Any]:
        """Converts a PayloadCmsJournalEntry to a dictionary, handling datetimes."""
        data = asdict(entry)

        def convert_datetimes(obj):
            if isinstance(obj, dict):
                return {k: convert_datetimes(v) for k, v in obj.items()}
            if isinstance(obj, list):
                return [convert_datetimes(i) for i in obj]
            if isinstance(obj, datetime):
                return obj.isoformat()
            return obj

        data = convert_datetimes(data)
        return {k: v for k, v in data.items() if v is not None and v != [] and v != {}}

    def register_entry(self, entry: JournalEntry) -> Any:
        # Step 1: Upload any new local files and get their IDs.
        uploaded_file_ids = []
        if entry.media_attachments:

            for att in entry.media_attachments:
                print(f"    - Inspecting attachment data: {att}")
                # This logic targets dicts with a 'path', typical of a new import.
                is_new_upload = isinstance(att, dict) and "path" in att
                print(f"    - Is this a new file to upload? {is_new_upload}")
                if is_new_upload:
                    path_exists = os.path.exists(att["path"])
                    print(f"    - Checking path: {att['path']}")
                    print(f"    - Does path exist? {path_exists}")
                    if path_exists:
                        print(f"    - Uploading local file: {att['filename']}...")
                        with open(att["path"], "rb") as f:
                            file_data = f.read()
                        uploaded_file_doc = self.upload_file(file_data, att["filename"])
                        uploaded_file_ids.append(uploaded_file_doc["id"])
                    else:
                        print(f"    - WARNING: Path not found for attachment, skipping file: {att['path']}")

                elif isinstance(att, MediaAttachment):
                    # If we are re-registering an entry that already has a file_id, preserve it.
                    uploaded_file_ids.append(att.file_id)

        # Step 2: Convert the JournalEntry to the base Payload entry DTO (without attachments).
        payload_entry = _journal_entry_to_payload_cms_entry(entry)

        # Step 3: Create the attachment blocks using the newly uploaded file IDs.
        payload_entry.attachments = [{"file": file_id} for file_id in uploaded_file_ids]
        if uploaded_file_ids:
            print(f"  -> Prepared {len(uploaded_file_ids)} attachments for entry payload.")

        # Step 4: Convert the final DTO to a dict and create the entry.
        payload_dict = self._payload_entry_to_dict(payload_entry)
        return self._make_request("POST", self.collection_slug, json=payload_dict)

    def register_entries(self, entries: list[JournalEntry]) -> list[Any]:
        results = []
        for idx, entry in enumerate(entries):
            print(f"Registering entry {idx + 1}/{len(entries)} (ID: {entry.id})...")
            try:
                result = self.register_entry(entry)
                results.append(result)
            except Exception as e:
                print(f"  ERROR: Failed to register entry {entry.id}. Reason: {e}")
        return results

    def update_entry(self, entry: JournalEntry) -> Any:
        # This update logic is complex as it would need to handle new, modified,
        # and removed attachments. For now, we focus on `update_journal_entry_attachments`.
        # A full implementation would require more sophisticated diffing.
        raise NotImplementedError("A full `update_entry` with attachment handling is not yet implemented.")

    def update_entries(self, entries: list[JournalEntry]) -> list[Any]:
        return [self.update_entry(entry) for entry in entries]

    def get_existing_entry_ids(self) -> list[str]:
        response = self._make_request("GET", f"{self.collection_slug}?limit=1000&depth=0")
        return [
            doc.get("source", {}).get("originalId")
            for doc in response.get("docs", [])
            if doc.get("source", {}).get("originalId")
        ]

    def get_existing_entries_with_modified_at(self) -> dict[str, datetime]:
        response = self._make_request("GET", f"{self.collection_slug}?limit=1000&depth=1")

        entries_map = {}
        for doc in response.get("docs", []):
            original_id = doc.get("source", {}).get("originalId")
            modified_str = doc.get("updatedAt")
            if original_id and modified_str:
                try:
                    entries_map[original_id] = datetime.fromisoformat(modified_str.replace("Z", "+00:00"))
                except (ValueError, TypeError):
                    print(f"Warning: Could not parse 'updatedAt' for entry {original_id}: {modified_str}")
        return entries_map

    def download_journal_entries(self) -> list[JournalEntry]:
        """Downloads all journal entries from Payload and converts them to JournalEntry objects."""
        print("Downloading and parsing journal entries from Payload CMS...")
        response = self._make_request("GET", f"{self.collection_slug}?limit=1000&depth=1")

        entries = []
        for doc in response.get("docs", []):
            try:
                entries.append(_payload_doc_to_journal_entry(doc))
            except Exception as e:
                doc_id = doc.get("id", "N/A")
                original_id = doc.get("source", {}).get("originalId", "N/A")
                print(f"Warning: Failed to parse document {doc_id} (original ID: {original_id}) from Payload. Error: {e}")
        return entries
